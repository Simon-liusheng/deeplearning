import torch.nn as nn
from common import Conv, C3, SPPF


class CspDarknet(nn.Module):
    def __init__(self, bc, bd):
        super().__init__()
        # -----------------------------------------------#
        #   输入图片是640, 640, 3
        #   初始的基本通道base_channels是64
        # -----------------------------------------------#

        # -----------------------------------------------#
        #   利用卷积结构进行特征提取
        #   640, 640, 3 -> 320, 320, 64
        # -----------------------------------------------#
        self.conv1 = Conv(3, bc, 6, 2, 2)
        # -----------------------------------------------#
        #   完成卷积之后，320, 320, 64 -> 160, 160, 128
        #   完成c3_1之后，160, 160, 128 -> 160, 160, 128
        # -----------------------------------------------#
        self.conv2 = Conv(bc, bc * 2, kernel_size=3, stride=2)
        self.c3_2 = C3(bc * 2, bc * 2, n=bd)

        # -----------------------------------------------#
        #   完成卷积之后，160, 160, 128 -> 80, 80, 256
        #   完成c3_2之后，80, 80, 256 -> 80, 80, 256
        #                   在这里引出有效特征层80, 80, 256
        #                   进行加强特征提取网络FPN的构建
        # -----------------------------------------------#
        self.conv3 = Conv(bc * 2, bc * 4, kernel_size=3, stride=2)
        self.c3_3 = C3(bc * 4, bc * 4, n=bd * 2)
        # -----------------------------------------------#
        #   完成卷积之后，80, 80, 256 -> 40, 40, 512
        #   完成c3_3之后，40, 40, 512 -> 40, 40, 512
        #                   在这里引出有效特征层40, 40, 512
        #                   进行加强特征提取网络FPN的构建
        # -----------------------------------------------#
        self.conv4 = Conv(bc * 4, bc * 8, kernel_size=3, stride=2)
        self.c3_4 = C3(bc * 8, bc * 8, n=bd * 3)
        # -----------------------------------------------#
        #   完成卷积之后，40, 40, 512 -> 20, 20, 1024
        #   完成CSPlayer之后，20, 20, 1024 -> 20, 20, 1024
        #   完成SPPF之后，20, 20, 1024 -> 20, 20, 1024
        # -----------------------------------------------#
        self.conv5 = Conv(bc * 8, bc * 16, kernel_size=3, stride=2)
        self.c3_5 = C3(bc * 16, bc * 16, n=bd)
        self.sppf = SPPF(bc * 16, bc * 16)

    def forward(self, x):
        x = self.conv1(x)
        p2 = self.c3_2(self.conv2(x))
        p3 = self.c3_3(self.conv3(p2))
        p4 = self.c3_4(self.conv4(p3))
        p5 = self.sppf(self.c3_5(self.conv5(p4)))
        return p3, p4, p5
